# CP1404 Practical Reflection

Write short but thoughtful answers to each of the following.  
Replace each `...` with your meaningful answer.

## Estimates

Regarding the **estimates** that you did for practical tasks...

### How was your estimate accuracy usually?

At first, my time estimates were honestly not very reliable. 
I'd often think, "This task should only take 30 minutes," and then I'd find myself still debugging it two hours later.
Most of the time, I underestimated how long it would take to figure out edge cases or understand the problem properly—especially with decisions and loops.



### How did your estimate accuracy improve or change during the course of the subject?

As the semester went on, I became more aware of the real work involved in completing a practical. 
I started to break tasks down into smaller chunks and give each part its own estimate. 
This helped me be more realistic—and less stressed when things took longer than expected. I also started padding extra time for debugging and testing, which turned out to be very necessary.

### What did you learn from doing these estimates?

Doing estimates forced me to think about what I was doing before I started coding, and I realized that good planning makes a huge difference. It also helped me build a better relationship with uncertainty: I don’t expect everything to go perfectly the first time anymore. 
It’s normal to hit unexpected bugs or logic issues, and now I plan for that
## Code Reviews

### What have you learned from being reviewed by other people?

One of the most useful things I learned is that clarity matters more than cleverness.
Reviewers often pointed out when my variable names were vague or when a function tried to do too many things. 
Even when my code worked, it didn’t always communicate well. These reviews helped me develop a mindset of writing code for other people, not just for myself.
### What have you learned from doing code reviews of other people?

Reviewing others' code helped me reflect on my own habits. When I saw repetitive patterns, magic numbers, or poorly named functions in someone else's work, I started spotting the same things in mine.
It also taught me how to give feedback in a way that’s helpful rather than judgmental—like asking “Have you thought about extracting this logic into a function?” instead of saying “This is bad.”



Provide proper Markdown links (not bare URLs) to two (2) PRs that show you doing good code reviews for any of the past
pracs.  
For each one, write a short explanation of what was good about your review.

### Good Code Review 1

https://github.com/NangLaungPhoung02/cp1404practicals/pull/1/files

### Explanation

I focused on input validation and suggested handling edge cases more robustly, especially with file I/O and list processing. I also emphasized aligning output formatting, which helped the submitter meet professional output expectations.



### Good Code Review 2

https://github.com/NangLaungPhoung02/cp1404practicals/pull/1/files
### Explanation

I highlighted the importance of using constants instead of magic numbers and added a comment about improving testability. I also suggested using better function names that reflect the task more clearly. This review encouraged more modular and readable code.
## Practicals

### Regarding the **practical tasks** overall, what would you change if you were in charge of the subject?

I think the practicals are very useful, but if I were in charge, I’d include more real-world mini projects earlier on—things like a basic budgeting app or a file-based note keeper. That would make abstract concepts like file I/O or functions feel more meaningful.

I’d also add more example solutions or "common mistakes" after each practical. Sometimes I finished a task but wasn’t sure if my approach was the most efficient or Pythonic. A little post-prac reflection resource could really help with that.

### What did you do really well for practicals in this subject?
I feel like I made solid progress in both my problem-solving mindset and code organization. Early on, I just tried to make things work, but later I started to care more about writing clean, testable functions with meaningful names and docstrings. I also practiced the Single Responsibility Principle more consciously—making functions do just one thing, and do it well.

And I think I got better at debugging. Instead of randomly inserting print statements, I learned to step back and trace through the logic calmly. That felt like a major growth point for me.

Also, version control! At the beginning, I barely used Git meaningfully. But by the end, I was making consistent, descriptive commits and even reviewing others' PRs. That’s something I’ll definitely carry into future projects.

